# This file is part of IntegerTriangles.
# Copyright Peter Luschny. License is MIT.

# Version of: UTC 2021-04-19 17:23:57
# 428f0a90-a123-11eb-347a-b7dc3db3fe2a

# Do not edit this file, it is generated from the modules and will be overwritten!
# Edit the modules in the src directory and build this file with BuildTriangles.jl!

__precompile__()
module IntegerTriangles
using Nemo, 
    HTTP, 
    DocStringExtensions, 
    OrderedCollections,
    PrettyTables
export 
AbstractSequence,
AbstractTriangle,
AltSum,
AssociatedTriangles,
BernoulliPolynomial,
Binomial,
BinomialTransform,
BinomialTriangle,
Catalan,
CatalanBallot,
CatalanTransform,
CatalanTriangle,
Central,
Coefficients,
DelehamΔ,
DiagSum,
DiagonalTriangle,
EgfExpansionCoeff,
EgfExpansionPoly,
EulerianTransform,
EulerianTriangle,
EulerianTriangle2,
Evaluate,
EvenSum,
Explore,
ExtCatalanTriangle,
Factorial,
FallingFactTriangle,
FibonacciTransform,
FibonacciTriangle,
Flat,
GetSeqnum,
InvRev,
Inverse,
InverseTriangle,
JacobsthalTransform,
JacobsthalTriangle,
Laguerre,
LaguerreTransform,
LaguerreTriangle,
LahNumbers,
LahTransform,
LahTriangle,
LeftSide,
LinMap,
Middle,
MotzkinTransform,
MotzkinTriangle,
NarayanaTransform,
NarayanaTriangle,
NegHalf,
OddSum,
OrthoPoly,
PascalTriangle,
PolyArray,
PolyTriangle,
PolyVal2,
PolyVal3,
PolyValue,
Polynomial,
PolynomialFunction,
PosHalf,
Print,
Println,
QInt,
QPolyRing,
QPolySeq,
QSeq,
QTri,
RecTriangle,
RevInv,
Reverse,
ReversePolynomial,
RightSide,
RiordanSquare,
SchroederBigTransform,
SchroederBigTriangle,
SchröderBTriangle,
SchröderLTriangle,
SeqToString,
Show,
StirlingCycleTransform,
StirlingCycleTriangle,
StirlingSetTransform,
StirlingSetTriangle,
TRAITS,
TRIANGLES,
Telescope,
TraitCard,
Trans,
TransAlts,
TransNat0,
TransNat1,
TransSqrs,
TransTraits,
TransUnos,
Triangles,
ZInt,
ZPolyRing,
ZPolySeq,
ZSeq,
ZTri,
oeis_notinstalled,
oeis_search,
profilepath,
search_failed,
xTraitCard,
ℚInt,
ℚPolyRing,
ℚPolySeq,
ℚSeq,
ℚTri,
ℤInt,
ℤPolyRing,
ℤPolySeq,
ℤSeq,
ℤTri,
I008279,T008279,
I048993,T048993,
I094587,T094587,
I132393,T132393,
I225478,T225478,
I271703,T271703
# *** TrianglesBase.jl ****************
import Base.sum
"""
Supertype for sequences (or sequence-like types).
"""
abstract type AbstractSequence end
"""
Supertype for triangles (or triangles-like types).
"""
abstract type AbstractTriangle end
const Seq{T} = Array{T,1}
"""
ℤInt is an alias for the type Nemo.fmpz.
"""
const ℤInt  = Nemo.fmpz
"""
ℚInt is an alias for the type Nemo.fmpq.
"""
const ℚInt  = Nemo.fmpq
"""
ℤSeq is an alias for the type Array{Nemo.fmpz, 1}.
"""
const ℤSeq = Seq{ℤInt}
"""
ℚSeq is an alias for the type Array{Nemo.fmpq, 1}.
"""
const ℚSeq = Seq{ℚInt}
"""
ℤTri is an alias for the type Array{Array{Nemo.fmpz, 1}, 1}.
"""
const ℤTri = Seq{ℤSeq}
"""
ℚTri is an alias for the type Array{Array{Nemo.fmpq, 1}, 1}.
"""
const ℚTri = Seq{ℚSeq}
"""
Constructor for an ℤSeq of length len. If a second parameter f
is given the sequence is constructed as [ZZ(f(n)) for n in 0:len-1]
"""
ZSeq(len::Int) = ℤSeq(undef, len)
ZSeq(len::Int, f::Function) = [ZZ(f(n)) for n in 0:len-1]
"""
Constructor for an ℚSeq of length len. If a second parameter f
is given the sequence is constructed as [QQ(f(n)) for n in 0:len-1]
"""
QSeq(len::Int) = ℚSeq(undef, len)
QSeq(len::Int, f::Function) = [QQ(f(n)) for n in 0:len-1]
"""
Constructor for ZTri.
"""
function ZTri(dim::Int; reg=false)
reg ? ZSeq.(1:dim) : ℤTri(undef, dim)
end
ZTri(dim, f::Function) = f.(0:dim-1)
ZTri(T::AbstractTriangle) = [row for row ∈ T]
"""
Constructor for QTri.
"""
function QTri(dim::Int; reg=false)
reg ? QSeq.(1:dim) : ℚTri(undef, dim)
end
"""
ℤPoly is an alias for the type Nemo.fmpz_poly.
"""
const ℤPoly = Nemo.fmpz_poly
"""
ℚPoly is an alias for the type Nemo.fmpq_poly.
"""
const ℚPoly = Nemo.fmpq_poly
"""
ℤPolySeq is an alias for the type Array{Nemo.fmpz_poly, 1}.
"""
const ℤPolySeq = Seq{ℤPoly}
"""
ℚPolySeq is an alias for the type Array{Nemo.fmpq_poly, 1}.
"""
const ℚPolySeq = Seq{ℚPoly}
"""
ℤPolyTri is an alias for the type Array{Array{Nemo.fmpz_poly, 1}, 1}.
"""
const ℤPolyTri = Seq{ℤPolySeq}
"""
ℚPolyTri is an alias for the type Array{Array{Nemo.fmpq_poly, 1}, 1}.
"""
const ℚPolyTri = Seq{ℚPolySeq}
ZPolyRing(x) = PolynomialRing(ZZ, x)
QPolyRing(x) = PolynomialRing(QQ, x)
const WARNING_ON_NOTINVERTIBLE = false
"""
Return the diagonal triangle T(n - k, k) where k in 0:n/2.
```
julia> Println.(DiagonalTriangle(MotzkinTriangle(8)))
[1]
[1]
[2, 1]        
[4, 2]        
[9, 5, 1]     
[21, 12, 3]   
[51, 30, 9, 1]
[127, 76, 25, 4]  # A106489
```
"""
function DiagonalTriangle(T::ℤTri)
dim = length(T)
U = ZTri(dim)
for n = 1:dim
R = ZSeq(div(n + 1, 2))
for k = 0:div(n - 1, 2)
R[k + 1] = T[n - k][k + 1]
end
U[n] = R
end
U
end
"""
The sum of a ℤTri is the sequence of the sum of the rows.
"""
Base.sum(T::ℤTri) = [sum(row) for row ∈ T]
Base.sum(T::ℚTri) = [sum(row) for row ∈ T]
"""
The EvenSum of a ℤSeq is the sum of the even indexed terms, indexing starts with 0.
```
julia> EvenSum([0, 1, 2, 3, 4, 5])
0 + 2 + 4 = 6
```
"""
EvenSum(A) = sum(A[1:2:end])
"""
The OddSum of a ℤSeq is the sum of the odd indexed terms, indexing starts with 0.
```
julia> OddSum([0, 1, 2, 3, 4, 5])
1 + 3 + 5 = 9
```
"""
OddSum(A) = sum(A[2:2:end])
"""
The AltSum of a ℤSeq is the alternating sum.
```
julia> AltSum([0, 1, 2, 3, 4, 5])
+ 0 - 1 + 2 - 3 + 4 - 5 = 6 - 9 = - 3
```
"""
AltSum(A) = EvenSum(A) - OddSum(A)
"""
The Middle of a ℤSeq A is the middle term, A[div(begin + end, 2)].
```
julia> Middle([0, 1, 2, 3, 4, 5])
3
```
"""
Middle(A) = A[div(begin + end, 2)]
"""
The LeftSide of a ℤSeq is the first term.
```
julia> LeftSide([0, 1, 2, 3, 4, 5])
0
```
"""
LeftSide(A) = A[begin]
"""
The RightSide of a ℤSeq is the last term.
```
julia> RightSide([0, 1, 2, 3, 4, 5])
5
```
"""
RightSide(A) = A[end]
"""
The EvenSum of a ℤTri is the sequence of the even sums of the rows.
```
EvenSum(T::ℤTri) = EvenSum.(T)
```
"""
EvenSum(T::ℤTri) = EvenSum.(T)
"""
The OddSum of a ℤTri is the sequence of the odd sums of the rows.
```
OddSum(T::ℤTri) = OddSum.(T)
```
"""
OddSum(T::ℤTri) = OddSum.(T)
"""
The AltSum of a ℤTri is the sequence of the alternating sums of the rows.
```
AltSum(T::ℤTri) = EvenSum(T) - OddSum(T)
```
"""
AltSum(T::ℤTri) = EvenSum(T) - OddSum(T)
"""
The DiagSum of a ℤTri is the sum of the diagonal triangle.
```
DiagSum(T::ℤTri) = sum(DiagonalTriangle(T))
```
"""
DiagSum(T::ℤTri) = sum(DiagonalTriangle(T))
"""
The Middle of a ℤTri is the sequence of the middle term in the rows.
```
Middle(T::ℤTri) = Middle.(T)
```
"""
Middle(T::ℤTri) = Middle.(T)
"""
The Central of a ℤTri is the sequence of the middle term
of the even indexed rows, indexing starts with 0.
```
Central(T::ℤTri) = Middle.(T[begin:2:end])
```
"""
Central(T::ℤTri) = Middle.(T[begin:2:end])
"""
The LeftSide of a ℤTri is the sequence of the first term in the rows.
```
LeftSide(T::ℤTri) = LeftSide.(T)
```
"""
LeftSide(T::ℤTri) = LeftSide.(T)
"""
The RightSide of a ℤTri is the sequence of the last term in the rows.
```
RightSide(T::ℤTri) = RightSide.(T)
```
"""
RightSide(T::ℤTri) = RightSide.(T)
"""
Return the ℤ-polynomial whose coefficients are the terms of the sequence.
```
[1, 2, 3] -> 1 + 2*x + 3*x^2
```
"""
function Polynomial(S::ℤSeq)
R, x = ZPolyRing("x")
sum(c * x^(k - 1) for (k, c) ∈ enumerate(S))
end
"""
Return the sequence of ℤ-polynomials whose coefficients are the terms of the triangle.
```
Polynomial(T::ℤTri) = Polynomial.(T)
```
"""
Polynomial(T::ℤTri) = Polynomial.(T)
"""
Return the ℤ-polynomial whose coefficients are the terms of the reversed sequence.
```
[1, 2, 3] -> x^2 + 2*x + 3
```
"""
ReversePolynomial(S::ℤSeq) = Polynomial(reverse(S))
"""
Return the sequence of ℤ-polynomials whose coefficients are the terms of the reversed triangle.
```
ReversePolynomial(T::ℤTri) = ReversePolynomial.(T)
```
"""
ReversePolynomial(T::ℤTri) = ReversePolynomial.(T)
"""
Return the polynomial function associated with the polynomial with coefficients
given by the sequence S. A polynomial function evaluates to Float64 values.
```
p = PolynomialFunction([1, 2, 3])
julia> [p(r) for r in 0:3]
4-element Vector{Float64}:
  1.0
  6.0
 17.0
 34.0
```
"""
function PolynomialFunction(S)
y -> sum(Float64(c) * y^(k - 1)
for (k, c) ∈ enumerate(S))
end
"""
Return the sequence of polynomial functions associated to the polynomials with coefficients
given by the triangle T.
```
PolynomialFunction(T::ℤTri) = PolynomialFunction.(T)
```
"""
PolynomialFunction(T::ℤTri) = PolynomialFunction.(T)
"""
Return the value of the ℤ-polynomial p evaluated at x.
```
julia> R, x = ZPolyRing("x")
p = 1 + 2*x + 3*x^2
Evaluate(p, 2)
17
```
"""
Evaluate(p::ℤPoly, x) = subst(p, x)
Evaluate(p::ℚPoly, x) = subst(p, x)
"""
Return the sequence of values to which the sequence of ℤ-polynomials P evaluate at x.
```
julia> R, x = ZPolyRing("x")
P = [sum(k * x^k for k in 0:n) for n in 0:9]
Evaluate(P, 3)  # A289399
```
"""
Evaluate(P::ℤPolySeq, x) = Evaluate.(P, x)
Evaluate(P::ℚPolySeq, x) = Evaluate.(P, x)
"""
Return the list of coefficients of the polynomial p (ordered by ascending powers).
```
julia> R, x = ZPolyRing("x")
p = 1 + 2*x + 3*x^2
Coefficients(p)
```
"""
Coefficients(p) = coeff.(p, 0:degree(p))
"""
Return the sequence of list of coefficients of the polynomials P.
"""
Coefficients(P::AbstractArray) = Coefficients.(P)
import Nemo.numerator
numerator(T::ℚTri) = [numerator.(t) for t ∈ T]
"""
Return numerator(2^degree(p) * Evaluate(p, QQ(1, 2))).
```
julia> R, x = ZPolyRing("x")
p = 1 + 2*x + 3*x^2
PosHalf(p)
11
```
"""
PosHalf(p) = numerator(2^degree(p) * Evaluate(p, QQ(1, 2)))
"""
Return Numerator((-2)^degree(p) * Evaluate(p, QQ(-1, 2)))
```
julia> R, x = ZPolyRing("x")
p = 1 + 2*x + 3*x^2
NegHalf(p)
3
```
"""
NegHalf(p) = numerator((-2)^degree(p) * Evaluate(p, QQ(-1, 2)))
"""
Return the sequence generated by broadcasting PosHalf over the
rows of the triangle interpreted as a polynomials.
```
julia> T = [[ZZ(k) for k in 0:n] for n in 1:5]
PosHalf(Polynomial(T))  # A000295
5-element ℤSeq
 1
 4
 11
 26
 57
```
"""
PosHalf(T::ℤTri) = PosHalf.(Polynomial(T))
"""
Return the sequence generated by broadcasting NegHalf over the
rows of the triangle interpreted as a polynomials.
```
NegHalf(T::ℤTri) = NegHalf.(Polynomial(T))
```
"""
NegHalf(T::ℤTri) = NegHalf.(Polynomial(T))
"""
Return the sequence generated by broadcasting PosHalf over the
sequence of polynomials.
"""
PosHalf(P::ℤPolySeq) = PosHalf.(P)
"""
Return the sequence generated by broadcasting NegHalf over the
sequence of polynomials.
"""
NegHalf(P::ℤPolySeq) = NegHalf.(P)
LinMap(M::ℤTri, V::ℤSeq, n) = sum(M[n][k] * V[k] for k = 1:n)
"""
LinMap(M::ℤTri, V::ℤSeq) returns the 'matrix times vector' product
of M and V. Expands up to length(V) and we assume length(M) >= length(V).
"""
LinMap(M::ℤTri, V::ℤSeq) = (n -> LinMap(M, V, n)).(1:length(V))
LinMap(F::Function, V::ℤSeq, n) = sum(F(n - 1)[k] * V[k] for k = 1:n)
"""
LinMap(F::Function, V::ℤSeq) returns the 'matrix times vector' product
of a matrix generated by F and V.
```
julia>  L(n) = [ZZ(k) for k in 0:n]
[LinMap(L, L(n)) for n in 0:9]
0
1
5
14
30
... # A000330
```
"""
LinMap(F::Function, V::ℤSeq) = LinMap(F, V, length(V))
"""
Transform a ℤSeq V by the matrix/vector product by applying LinMap to (M, V).
Expands up to min(length(M), length(V)).
"""
Trans(M::ℤTri, V::ℤSeq) = (n -> LinMap(M, V, n)).(1:min(length(M), length(V)))
"""
TransUnos(T) = Trans(T, [ZZ(1) for n = 0:length(T)])

Standard trait of T.
"""
TransUnos(T) = Trans(T, [ZZ(1) for n = 0:length(T)])
"""
TransAlts(T) = Trans(T, [(-1)^n * ZZ(1) for n = 0:length(T)])

Standard trait of T.
"""
TransAlts(T) = Trans(T, [(-1)^n * ZZ(1) for n = 0:length(T)])
"""
TransSqrs(T) = Trans(T, [ZZ(n^2) for n = 0:length(T)])

Standard trait of T.
"""
TransSqrs(T) = Trans(T, [ZZ(n^2) for n = 0:length(T)])
"""
TransNat0(T) = Trans(T, [ZZ(n) for n = 0:length(T)])

Standard trait of T.
"""
TransNat0(T) = Trans(T, [ZZ(n) for n = 0:length(T)])
"""
TransNat1(T) = Trans(T, [ZZ(n) for n = 1:length(T)])

Standard trait of T.
"""
TransNat1(T) = Trans(T, [ZZ(n) for n = 1:length(T)])
"""
Return an iterator expanding the given sequence to a regular triangle.
```
julia> T = Telescope(ℤInt[1, 2, 3, 4, 5, 6])
collect(T)
 [1]
 [1, 2]
 [1, 2, 3]
 [1, 2, 3, 4]
 [1, 2, 3, 4, 5]
 [1, 2, 3, 4, 5, 6]
```
"""
Telescope(A::ℤSeq) = (A[1:k] for k = 1:size(A, 1))
"""
Return an iterator expanding the sequence generated by the function f to a regular triangle.
"""
Telescope(len::Int, f::Function) = Telescope([ZZ(f(k)) for k = 0:len - 1])
"""
Return the factorial ``n! = ∏(1, n)``.
"""
Factorial(n) = Nemo.factorial(ZZ(n))
Binomial(n, k) = Nemo.binomial(ZZ(n), ZZ(k))
Binomial(n) = [Binomial(n, k) for k = 0:n]
Binomial(A::ℤSeq) = LinMap(Binomial, A)
BinomialTriangle(dim) = [Binomial(n) for n = 0:dim - 1]
BinomialTransform(A::ℤSeq) = Binomial.(Telescope(A))
Laplace(s, k) = factorial(k) * coeff(s, k)
"""
Return the Laplace expansion of a bivariate exponential
generating function as a power series, or, if 'coeff=true',
as the coefficients of the series.
"""
function EgfExpansion(prec, gf::Function, coeff=true)
R, x = QPolyRing("x")
S, t = PowerSeriesRing(R, prec + 1, "t")
ser = gf(x, t)
P = Laplace.(ser, 0:prec - 1)
coeff ? Coefficients.(P) : P
end
"""
Return the Laplace expansion of a bivariate exponential
generating function as a power series.
"""
EgfExpansionCoeff(prec, gf::Function) = EgfExpansion(prec, gf, true)
"""
Return the Laplace expansion of a bivariate exponential generating
function as a list of the coefficients of the power series.
"""
EgfExpansionPoly(prec, gf::Function) = EgfExpansion(prec, gf, false)
function OrthoPoly(dim::Int, s::Function, t::Function)
T = ZTri(dim, reg=true) # regular triangle
for n ∈ 1:dim T[n][n] = 1 end
for n ∈ 2:dim
u(k) = k == 0 || k == n ? 0 : T[n - 1][k]
for k ∈ 1:n - 1
T[n][k] = (u(k - 1) + s(k - 1) * u(k) + t(k) * u(k + 1))
end
end
T
end
function DelehamΔ(dim::Int, s::Function, t::Function)
T = ZTri(dim)
R, x = ZPolyRing("x")
A = [R(s(k) + x * t(k)) for k ∈ 0:dim - 2]
C = [R(1) for i ∈ 0:dim]
C[1] = R(0)
m = 1
for k ∈ 0:dim - 1
for j ∈ k + 1:-1:2
C[j] = C[j - 1] + C[j + 1] * A[j - 1]
end
T[m] = [coeff(C[2], j) for j ∈ 0:k]
m += 1
end
T
end
function RiordanSquare(dim::Int, s::Function)
T = ZTri(dim, reg=true)
for n ∈ 0:dim - 1
T[n + 1][1] = s(n)
end
for k ∈ 1:dim - 1, m ∈ k:dim - 1
T[m + 1][k + 1] = sum(T[j][k] * T[m - j + 2][1] for j ∈ k:m)
end
T
end
function ExpRiordanSquare(dim::Int, s::Function)
R = RiordanSquare(dim, s)
u = ZZ(1)
for k ∈ 1:dim - 1
u *= k
for m ∈ 1:k
j = (m == 1 ? u : div(j, m - 1))
R[k + 1][m] *= j
end
end
R
end
function check(invM, dim)
for n = 1:dim
for k = 1:n
if denominator(invM[n, k]) != 1
return false
end
end
end
return true
end
function InverseTriangle(T)
dim = length(T)
M = zeros(QQ, dim, dim)
for n in 1:dim, k in 1:n
M[n, k] = QQ(T[n][k])
end
S = MatrixSpace(QQ, dim, dim)
invM = try
inv(S(M))
catch e
if isa(e, Exception)
if WARNING_ON_NOTINVERTIBLE
@warn("\n\n Not invertible!\n\n")
end
return []
end
end
if check(invM, dim) != true
if WARNING_ON_NOTINVERTIBLE
@warn("\n\n Inverse not in MatrixSpace(ZZ)!\n\n")
end
return []
end
return [[numerator(invM[n, k]) for k = 1:n] for n = 1:dim]
end
"""
Alias for InverseTriangle
"""
Inverse(T::ℤTri) = InverseTriangle(T)
"""
Return the row reversed triangle.
"""
Reverse(T::ℤTri) = reverse.(T)
function RevInv(T::ℤTri)
I = Inverse(T)
return I != [] ? Reverse(I) : []
end
InvRev(T::ℤTri) = Inverse(Reverse(T))
function Flat(T::ℤTri)
T === [] && return []
Empty(s) = isempty(s) ? [ZZ(0)] : s
[z for t ∈ T for z ∈ Empty(t)]
end
function Println(io, v::AbstractVector, newline=true)
print(io, "[")
for (i, el) ∈ enumerate(v)
i > 1 && print(io, ", ")
print(io, el)
end
newline ? println(io, "]") : print(io, "]")
end
Println(io, str::String) = println(io, str)
Println(T::ℤTri) = Println.(IOContext(stdout), T)
Println(T::ℤSeq) = Println(IOContext(stdout), T)
Print(io, str::String) = print(io, str)
Print(T::ℤTri) = Println.(IOContext(stdout), T, false)
Print(T::ℤSeq) = Println(IOContext(stdout), T, false)
"""
A recursive triangle `RecTriangle` is a subtype of `AbstractTriangle`. The rows
of the triangle are generated by a function `gen(n, k, prevrow)` defined for
``n ≥ 0`` and ``0 ≤ k ≤ n``. The function returns value of type ℤInt.

The parameter prevrow is a function which returns the values of `row(n-1)` of
the triangle and 0 if ``k < 0`` or ``k > n``. The function prevrow is provided
by an instance of `RecTriangle` and must not be defined by the user.
"""
struct RecTriangle <: AbstractTriangle
dim::Int
A::ℤSeq
gen::Function  # generating function
function RecTriangle(dim::Int, gen::Function)
dim <= 0 && throw(ArgumentError("dim has to be a positive integer."))
new(
dim,
fill(ZZ(0), dim),
(n::Int, k::Int, f::Function) -> gen(n, k, f)::ℤInt,
)
end
end
function Base.iterate(T::RecTriangle)
top = T.gen(0, 0, () -> undef)
T.A[1] = ZZ(top)
([top], 1)
end
"""
Return the next row of the triangle.
"""
function Base.iterate(T::RecTriangle, n)
@inline prevrow(A, n) = (k) -> (k < 0 || k > n) ? ZZ(0) : A[k + 1]
n == T.dim && return nothing
F(n, k) = T.gen(n, k, prevrow(T.A, n))
row = [F(n, k) for k ∈ 0:n]
for k ∈ 1:n + 1
T.A[k] = row[k]
end
(row, n + 1)
end
Base.length(R::RecTriangle) = R.dim
Base.eltype(R::RecTriangle) = ℤInt
function PolyArray(T::ℤTri)
P = Polynomial(T)
dim = length(T)
U = ZTri(dim)
for n = 1:dim
p = P[n]
eva = [Evaluate(p, k) for k in 0:dim - 1]
U[n] = numerator.(eva)
end
U
end
function PolyTriangle(T::ℤTri)
A = PolyArray(T)
U = ZTri(length(T))
for n = 1:length(T)
U[n] = [A[n - k][k + 1] for k = 0:n - 1]
end
U
end
function PolyValue(T::ℤTri, k::Int)
P = PolyArray(T)
[P[n][k + 1] for n = 1:length(P)]
end
PolyVal2(T::ℤTri) = PolyValue(T, 2)
PolyVal3(T::ℤTri) = PolyValue(T, 3)
const TRAITS = Function[
Flat,
Reverse,
Inverse,
RevInv,
InvRev,
sum,
EvenSum,
OddSum,
AltSum,
DiagSum,
Middle,
Central,
LeftSide,
RightSide,
PosHalf,
NegHalf,
PolyVal2,
PolyVal3,
TransUnos,
TransAlts,
TransSqrs,
TransNat0,
TransNat1
]
# *** TrianglesExamples.jl ****************
function PrimeDivisors(n)
n < 2 && return ZInt[]
sort!([p for (p, e) ∈ factor(ZZ(n))])
end
const CacheLah = Dict{Int,Array{fmpz,1}}([0 => [ZZ(1)]])
function LahNumbers(n::Int64)
haskey(CacheLah, n) && return CacheLah[n]
prevrow = LahNumbers(n - 1)
row = ZSeq(n + 1)
row[1] = 0
row[n + 1] = 1
for k = 2:n
row[k] = prevrow[k - 1] + prevrow[k] * (n + k - 2)
end
CacheLah[n] = row
end
LahNumbers(n, k) = LahNumbers(n)[k + 1]
function LahTriangle(size)
length(CacheLah) < size && LahNumbers(size)
[CacheLah[n] for n = 0:size - 1]
end
LahNumbers(A::ℤSeq) = LinMap(LahNumbers, A, length(A))
LahTransform(A::ℤSeq) = LahNumbers.(Telescope(A))
G271703(x, t) = exp(t * divexact(x, 1 - t))
T271703(dim) = EgfExpansionCoeff(dim, G271703)
egfBernoulli(x, t) = divexact(t * exp(x * t), exp(t) - 1)
BernoulliPolynomial(n) = EgfExpansionPoly(n, egfBernoulli)
G278075(x, t) = divexact(1, 1 - x * (1 - exp(-t)))
FubiniPolynomial(n) = EgfExpansionPoly(n, G278075)
function MotzkinTriangle2(dim::Int)
T = ZTri(dim)
for n = 1:dim
T[n][n] = 1
end
for n = 2:dim
u(k) = k == 0 || k == n ? 0 : T[n - 1][k]
for k = 1:n - 1
T[n][k] = u(k - 1) + u(k) + u(k + 1)
end
end
T
end
MotzkinTriangle(dim) = OrthoPoly(dim, n -> 1, n -> 1)
Motzkin(n) = MotzkinTriangle(n + 1)[n + 1] # TODO!!
Motzkin(n, k) = Motzkin(n)[k + 1]
Motzkin(A::ℤSeq) = LinMap(Motzkin, A, length(A))
MotzkinTransform(A::ℤSeq) = Motzkin.(Telescope(A))
CatalanTriangle(dim) = OrthoPoly(dim, n -> 0, n -> 1)
Catalan(n) = CatalanTriangle(n + 1)[n + 1] # TODO!!
Catalan(n::Int, k::Int) = Catalan(n)[k + 1]
Catalan(A::ℤSeq) = LinMap(Catalan, A, length(A))
CatalanTransform(A::ℤSeq) = Catalan.(Telescope(A))
const CacheBallot = Dict{Tuple{Int,Int},fmpz}()
function CatalanBallot(n::Int, k::Int)
haskey(CacheBallot, (n, k)) && return CacheBallot[(n, k)]
(k > n || k < 0) && return ZZ(0)
n == k && return ZZ(1)
CacheBallot[(n, k)] = (
CatalanBallot(n - 1, k - 1) +
CatalanBallot(n - 1, k + 1) +
(iseven(n - k) ? 0 : CatalanBallot(n - 1, k))
)
end
CatalanBallot(n) = [CatalanBallot(n, k) for k ∈ 0:n]
ExtCatalanTriangle(dim) = [[CatalanBallot(n, k) for k = 0:n] for n = 0:dim - 1]
bs(n) = iszero(n) ? 0 : isodd(n) ? 2 : 1
SchröderBTriangle(dim) = DelehamΔ(dim, bs, n -> 0^n)
ls(n) = isodd(n) ? 2 : 1
SchröderLTriangle(dim) = DelehamΔ(dim, ls, n -> 0^n)
"""
Recurrence for A132393, StirlingCycle numbers.
"""
function R132393(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
(n - 1) * prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A048993, StirlingSet numbers.
"""
function R048993(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
k * prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A271703, Lah numbers.
"""
function R271703(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
(k - 1 + n) * prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A094587, (Rising factorials).
"""
function R094587(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
(n - k) * prevrow(k) + prevrow(k - 1)
end
"""
Recurrence for A008279. Number of permutations of n things k at a time.
(Falling factorials)
"""
function R008279(n::Int, k::Int, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
prevrow(k) + k * prevrow(k - 1)
end
"""
xIterates over the first n rows of `A132393`.
Triangle of unsigned Stirling numbers of the first kind.
"""
I132393(n) = RecTriangle(n, R132393)
T132393(dim) = ZTri(I132393(dim))
StirlingCycleTriangle(dim) = T132393(dim)
StirlingCycle(n) = StirlingCycleTriangle(n + 1)[n + 1]
StirlingCycle(n, k) = StirlingCycle(n)[k + 1]
StirlingCycle(A::ℤSeq) = LinMap(StirlingCycle, A, length(A))
StirlingCycleTransform(A::ℤSeq) = StirlingCycle.(Telescope(A))
"""
Iterates over the first n rows of `A048993`.
Triangle of Stirling numbers of 2nd kind.
"""
I048993(n) = RecTriangle(n, R048993)
T048993(dim) = ZTri(I048993(dim))
StirlingSetTriangle(dim) = T048993(dim)
StirlingSet(n) = StirlingSetTriangle(n + 1)[n + 1]
StirlingSet(n, k) = StirlingSet(n)[k + 1]
StirlingSet(A::ℤSeq) = LinMap(StirlingSet, A, length(A))
StirlingSetTransform(A::ℤSeq) = StirlingSet.(Telescope(A))
"""
Iterates over the first n rows of `A094587`.
"""
I094587(n) = RecTriangle(n, R094587)
T094587(dim) = ZTri(I094587(dim))
"""
Iterates over the first n rows of `A008279`.
"""
I008279(n) = RecTriangle(n, R008279)
T008279(dim) = ZTri(I008279(dim))
FallingFactTriangle(dim) = ZTri(I008279(dim))
PermCoeffsTriangle(dim) = ZTri(I008279(dim))
function R225478(n, k, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
4 * prevrow(k - 1) + (4 * n - 1) * prevrow(k)
end
I225478(dim) = RecTriangle(dim, R225478)
T225478(dim) = ZTri(I225478(dim))
function R007318(n, k, prevrow::Function)
(k == 0 && n == 0) && return ZZ(1)
prevrow(k - 1) + prevrow(k)
end
I007318(dim) = RecTriangle(dim, R007318)
PascalTriangle(dim) = ZTri(I007318(dim))
function SchroederBig(n, k)
div(
(k + 1) * sum(Binomial(n + 1, k + j + 1) *
Binomial(n + j, j) for j = 0:(n - k)),
n + 1,
)
end
function SchroederBigTriangle(dim)
[[SchroederBig(n, k) for k = 0:n] for n = 0:dim - 1]
end
SchroederBig(n) = SchroederBigTriangle(n + 1)[n + 1]
SchroederBig(A::ℤSeq) = LinMap(SchroederBig, A, length(A))
SchroederBigTransform(A::ℤSeq) = SchroederBig.(Telescope(A))
FJ(n, k) = n <= 2 ? 1 : FJ(n - 1, k) + k * FJ(n - 2, k)
JacobsthalTriangle(dim) = RiordanSquare(dim, n -> FJ(n, 2))
Jacobsthal(n) = JacobsthalTriangle(n + 1)[n + 1]
Jacobsthal(n, k) = Jacobsthal(n)[k + 1]
Jacobsthal(A::ℤSeq) = LinMap(Jacobsthal, A, length(A))
JacobsthalTransform(A::ℤSeq) = Jacobsthal.(Telescope(A))
FibonacciTriangle(dim) = RiordanSquare(dim, n -> FJ(n, 1))
Fibonacci(n) = FibonacciTriangle(n + 1)[n + 1]
Fibonacci(n, k) = Fibonacci(n)[k + 1]
Fibonacci(A::ℤSeq) = LinMap(Fibonacci, A, length(A))
FibonacciTransform(A::ℤSeq) = Fibonacci.(Telescope(A))
const CacheEulerian = Dict{Tuple{Int,Int},fmpz}()
function EulerianNumbers(n, k)
haskey(CacheEulerian, (n, k)) && return CacheEulerian[(n, k)]
CacheEulerian[(n, k)] = if (k == 0) && (n >= 0)
ZZ(1)
elseif (k < 0) || (k > n)
ZZ(0)
else
(n - k) * EulerianNumbers(n - 1, k - 1) +
(k + 1) * EulerianNumbers(n - 1, k)
end
end
EulerianTriangle(dim) = [[EulerianNumbers(n, k) for k = 0:n] for n = 0:dim - 1]
Eulerian(n) = EulerianTriangle(n + 1)[n + 1]
Eulerian(n, k) = Eulerian(n)[k + 1]
Eulerian(A::ℤSeq) = LinMap(Eulerian, A, length(A))
EulerianTransform(A::ℤSeq) = Eulerian.(Telescope(A))
const CacheEulerian2 = Dict{Tuple{Int,Int},fmpz}()
function EulerianNumbers2(n, k)
haskey(CacheEulerian2, (n, k)) && return CacheEulerian2[(n, k)]
CacheEulerian2[(n, k)] = if (k == n) 
ZZ(1)
elseif (k <= 0) || (k > n)
ZZ(0)
else
(n - k + 1) * EulerianNumbers2(n - 1, k - 1) +
(k) * EulerianNumbers2(n - 1, k)
end
end
EulerianTriangle2(dim) = [[EulerianNumbers2(n, k) for k = 0:n] for n = 0:dim - 1]
Eulerian2(n) = EulerianTriangle2(n + 1)[n + 1]
Eulerian2(n, k) = Eulerian2(n)[k + 1]
Eulerian2(A::ℤSeq) = LinMap(Eulerian2, A, length(A))
EulerianTransform2(A::ℤSeq) = Eulerian2.(Telescope(A))
const CacheNarayana = Dict{Tuple{Int,Int},fmpz}()
function NarayanaNumbers(n::Int, k::Int)
haskey(CacheNarayana, (n, k)) && return CacheNarayana[(n, k)]
CacheNarayana[(n, k)] = if (k == n)
ZZ(1)
elseif k > n || k <= 0
ZZ(0)
else
div(
Binomial(ZZ(n), n - k) * Binomial(ZZ(n - 1), n - k),
ZZ(n - k + 1),
)
end
end
NarayanaTriangle(dim) = [[NarayanaNumbers(n, k) for k = 0:n] for n = 0:dim]
Narayana(n) = NarayanaTriangle(n + 1)[n + 1]
Narayana(n, k) = Narayana(n)[k + 1]
Narayana(A::ℤSeq) = LinMap(Narayana, A, length(A))
NarayanaTransform(A::ℤSeq) = Narayana.(Telescope(A))
const CacheLaguerre = Dict{Int,ℤSeq}(0 => [ZZ(1)])
function Laguerre(n::Int)
haskey(CacheLaguerre, n) && return CacheLaguerre[n]
prevrow = Laguerre(n - 1)
row = ZSeq(n + 1)
row[n + 1] = ZZ(1)
for k ∈ 1:n
row[k] = ( get(prevrow, k - 1, 0)
+ get(prevrow, k,   0) * (2 * k - 1)
+ get(prevrow, k + 1, 0) * k^2
)
end
CacheLaguerre[n] = row
end
Laguerre(n::Int, k::Int) = Laguerre(n)[k + 1]
Laguerre(A::ℤSeq) = LinMap(Laguerre, A, length(A))
function LaguerreTriangle(size::Int)
length(CacheLaguerre) < size && Laguerre(size)
[CacheLaguerre[n] for n in 0:size - 1]
end
LaguerreTransform(A::ℤSeq) = Laguerre.(Telescope(A))
function transforms(trans)
len = 18
println("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
println(trans)
println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
println()
Unos = [ZZ(1) for n = 0:len]
print("UNOS ")
Println(Unos)
trans(Unos) |> Println
println()
AltUnos = [(-1)^n * ZZ(1) for n = 0:len]
println("ALTS ")
Println(AltUnos)
trans(AltUnos) |> Println
println()
Squares = [ZZ(n^2) for n = 0:len]
println("SQRS ")
Println(Squares)
trans(Squares) |> Println
println()
Nat = [ZZ(n) for n = 0:len]
println("N0TS ")
Println(Nat)
trans(Nat) |> Println
println()
Nut = [ZZ(n) for n = 1:len]
println("NATS ")
Println(Nut)
trans(Nut) |> Println
end
const TRIANGLES = Function[
BinomialTriangle,
CatalanTriangle,
EulerianTriangle,
FibonacciTriangle,
LaguerreTriangle,
LahTriangle,
MotzkinTriangle,
NarayanaTriangle,
SchröderBTriangle,
SchröderLTriangle,
StirlingCycleTriangle,
StirlingSetTriangle,
FallingFactTriangle
]
# *** TrianglesExplorer.jl ****************
const WARNING_ON_NOTFOUND = false
const Kind = ["Std", "Rev", "Inv", "RevInv", "InvRev"]
const Triangles = LittleDict{String, Function}(
"Binomial"      => BinomialTriangle,
"Catalan"       => CatalanTriangle,
"Eulerian"      => EulerianTriangle,
"Fibonacci"     => FibonacciTriangle,
"Laguerre"      => LaguerreTriangle,
"Lah"           => LahTriangle,
"Motzkin"       => MotzkinTriangle,
"Narayana"      => NarayanaTriangle,
"SchroederB"    => SchröderBTriangle,
"SchroederL"    => SchröderLTriangle,
"StirlingCycle" => StirlingCycleTriangle,
"StirlingSet"   => StirlingSetTriangle,
"FallingFact"   => FallingFactTriangle
)
const Traits = LittleDict{String, Function}(
"Triangle"   => Flat,
"Reverse"    => Reverse,
"Inverse"    => Inverse,
"RevInv"     => RevInv,
"InvRev"     => InvRev,
"Sum"        => sum,
"EvenSum"    => EvenSum,
"OddSum"     => OddSum,
"AltSum"     => AltSum,
"DiagSum"    => DiagSum,
"Middle"     => Middle,
"Central"    => Central,
"LeftSide"   => LeftSide,
"RightSide"  => RightSide,
"PosHalf"    => PosHalf,
"NegHalf"    => NegHalf,
"PolyVal2"   => PolyVal2,
"PolyVal3"   => PolyVal3,
"TransUnos"  => TransUnos,
"TransAlts"  => TransAlts,
"TransSqrs"  => TransSqrs,
"TransNat0"  => TransNat0,
"TransNat1"  => TransNat1
)
function Show(io, name, kind, trait, seq, savetofile=false)
anum = GetSeqnum(seq, WARNING_ON_NOTFOUND)
if savetofile
print(".")
print(io, anum, " ", name, " ", kind, " ", trait, " ")
Println(io, seq[1:min(8, end)])
else
print(anum, " ", name, " ", kind, " ", trait, " ")
Println(seq[1:min(8, end)])
end
end
function TriangleVariant(Tri, dim, kind="Std")
if ! (kind in Kind)
@warn("No valid kind!")
return []
end
M = Tri(dim)
kind == "Std" && return M
kind == "Rev" && return reverse.(M)
kind == "InvRev" && (M = reverse.(M))
invM = InverseTriangle(M)
(kind == "Inv" || kind == "InvRev"
|| invM == []) && return invM
return reverse.(invM)
end
const LEN = 32
function Explore(triangle, kind, trait, dim)
T = TriangleVariant(Triangles[triangle], dim, kind)
seq = Traits[trait](T)
Show(stdout, triangle, kind, trait, seq)
end
function Explore(T::ℤTri, trait::Function)
seq = trait(T)
if seq == [] || seq === nothing
return []
end
typeof(seq) === ℤTri && (seq = Flat(seq))
anum = GetSeqnum(seq, WARNING_ON_NOTFOUND)
anum === nothing && (anum = "nothing")
seqstr = string(seq[1:min(9, end)])[max(0,11):max(0,end-1)]
String["$trait ", anum, seqstr]
end
"""

"""
function Explore(triangle, kind, trait)
dim = 32
T = TriangleVariant(Triangles[triangle], dim, kind)
seq = Traits[trait](T)
anum = GetSeqnum(seq)
anum === nothing && (anum = "nothing")
seqstr = string(seq[1:min(8, end)])[max(0,11):max(0,end-1)]
String[anum, triangle, kind, trait, seqstr]
end
function Explore(trait::String, dim::Int)
for (name, triangle) in Triangles
for kind in Kind
T = TriangleVariant(triangle, dim, kind)
if T != []
seq = Traits[trait](T)
Show(stdout, name, kind, trait, seq)
end
end
end
end
function Explore(savetofile::Bool)
@warn "This will take several minutes and produce the file 'BIGLIST.md' in the data directory."
open(profilepath("BIGLIST"), "a") do io
for (name, triangle) in Triangles
for kind in Kind
T = TriangleVariant(triangle, LEN, kind)
if T != []
for (trait, f) in Traits
Show(io, name, kind, trait, f(T), savetofile)
end
end
end
end
end
end
# *** TrianglesPlot.jl ****************
function PolyPlot(F, title)
x = -2.0:0.05:1.0
plot(x,  F[1], c="black",  linewidth=1)
plot!(x, F[2], c="green",  line=:dash)
plot!(x, F[3], c="blue",   linewidth=1)
plot!(x, F[4], c="red",    line=:dash)
plot!(x, F[5], c="orange", linewidth=1)
plot!(x, F[6], c="blue",   line=:dash)
plot!(x, F[7], c="black",  linewidth=1)
title!(title)
xlabel!("x")
ylabel!("p(x)")
P = plot!(xlims=(-2.0, 1.0), ylims=(-5.0, 5.0))
display(P)
end
# *** TrianglesTables.jl ****************
function PrettyTraits(T, name)
header = [ "Trait", "Anumber", "Sequence" ]
mat = String[name "" ""]
for tra in TRAITS
s = Explore(T, tra) 
s == [] && continue
mat = [mat; reshape(s, 1, 3)]
end
open(profilepath(name), "a") do io
pretty_table(io, mat, header, alignment=[:l,:l,:l])
end
end
function AllPrettyTraits()
for T in Triangles
PrettyTraits(Triangles[T[1]](32), T[1])
end
end
# *** TrianglesTraitCard.jl ****************
const SEARCH = true
function TraitCard(T::ℚTri, name)
println("WRONG TYPE! Will not process!")
println(name)
println()
end
function TraitCard(T::ℤTri, name, N, an=false)
an = an && ! oeis_notinstalled()
println("\n=================")
println(name)
println()
P = Polynomial(T)
len = max(N, min(N - 1, length(T)))
len = len < 10 ? len : 10
S = Flat(T); print("Triangle:  ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
R = Reverse(T)
FR = Flat(R); print("Reverse:   ")
an && print(GetSeqnum(FR, SEARCH), " ")
FR[1:len] |> Println
I = Inverse(T)
if I != []
FI = Flat(I); print("Inverse:   ")
an && print(GetSeqnum(FI, SEARCH), " ")
FI[1:len] |> Println
RI = Reverse(I)
RI = Flat(RI); print("RevInv:    ")
an && print(GetSeqnum(RI, SEARCH), " ")
RI[1:len] |> Println
end
IR = Inverse(R)
if IR != []
IR = Flat(IR); print("InvRev:    ")
an && print(GetSeqnum(IR, SEARCH), " ")
IR[1:len] |> Println
end
S = DiagonalTriangle(T)
S = Flat(S);
print("Diagonal:  ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = sum(T);       print("Sum:       ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = EvenSum(T);   print("EvenSum:   ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = OddSum(T);    print("OddSum:    ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = AltSum(T);    print("AltSum:    ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = DiagSum(T);   print("DiagSum:   ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = Central(T);   print("Central:   ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:min(len, length(S))] |> Println
S = LeftSide(T);  print("LeftSide:  ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = RightSide(T); print("RightSide: ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = PosHalf(P);  print("PosHalf:   ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = NegHalf(P);  print("NegHalf:   ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = Trans(T, [ZZ(1) for n = 0:32]); print("TransUnos: ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = Trans(T, [ZZ((-1)^n) for n = 0:32]); print("TransAlts: ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = Trans(T, [ZZ(n^2) for n = 0:32]); print("TransSqrs: ");
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = Trans(T, [ZZ(n) for n = 0:32]); print("TransNat0: ");
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = Trans(T, [ZZ(n) for n = 1:32]); print("TransNat1: ");
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = PolyVal2(T); print("PolyVal2:  ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
S = PolyVal3(T); print("PolyVal3:  ")
an && print(GetSeqnum(S, SEARCH), " ")
S[1:len] |> Println
end
"""
Print the standard traits generated by linear transformation.
```
julia> TransTraits(BinomialTriangle)
BinomialTriangle
TransUnos: A000079 [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
TransAlts: A000007 [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
TransSqrs: A001788 [0, 1, 6, 24, 80, 240, 672, 1792, 4608, 11520]
TransNat0: A001787 [0, 1, 4, 12, 32, 80, 192, 448, 1024, 2304]
TransNat1: A001792 [1, 3, 8, 20, 48, 112, 256, 576, 1280, 2816]
```
"""
function TransTraits(triangle::Function)
dim = 32
T = triangle(dim)
println("$triangle ")
len = min(10, min(dim - 1, length(T)))
S = Trans(T, [ZZ(1) for n = 0:dim]); anum = GetSeqnum(S, false)
print("TransUnos: ", anum, " "); S[1:len] |> Println
S = Trans(T, [ZZ((-1)^n) for n = 0:dim]); anum = GetSeqnum(S, false)
print("TransAlts: ", anum, " "); S[1:len] |> Println
S = Trans(T, [ZZ(n^2) for n = 0:dim]);    anum = GetSeqnum(S, false)
print("TransSqrs: ", anum, " "); S[1:len] |> Println
S = Trans(T, [ZZ(n) for n = 0:dim]);      anum = GetSeqnum(S, false)
print("TransNat0: ", anum, " "); S[1:len] |> Println
S = Trans(T, [ZZ(n) for n = 1:dim]);      anum = GetSeqnum(S, false)
print("TransNat1: ", anum, " "); S[1:len] |> Println
println()
end
function AssociatedTriangles(T::ℤTri, N)
len = max(N, min(N - 1, length(T)))
println("\nTriangle:\n")
for row in T[1:len] Println(row) end
println()
S = Flat(T); print("Flat triangle:  "); S[1:len] |> Println
println("\nInverse triangle:\n")
S = InverseTriangle(T)
if S != []
for row in S[1:len] Println(row) end
println()
S = Flat(S); print("Inverse:  "); S[1:len] |> Println
end
println("\nDiagonal triangle:\n")
S = DiagonalTriangle(T)
Println.(S[1:len])
println()
S = Flat(S); print("Diagonal:  "); S[1:len] |> Println
println("\nPolynomial values, array:\n")
Println.(PolyArray(T))
println("\nPolynomial values, triangle:\n")
S = PolyTriangle(T)
Println.(S[1:len])
println()
S = Flat(S); print("PolyVal:  "); S[1:len] |> Println
end
"""
Prints a list of traits of the triangle without Anums
and, if assoc=true, also a list of associated triangles.
"""
function TraitCard(triangle::Function, dim=8, assoc=false)
T = triangle(dim)
TraitCard(T, "$triangle ", dim)
AssociatedTriangles(T, dim)
end
"""
Prints a list of traits of the triangle with Anums.
xTraitCard is slower and uses much more resources than TraitCard.
```
julia> xTraitCard(LaguerreTriangle)
Triangle:  A021009 [1, 1, 1, 2, 4, 1, 6, 18, 9, 1]
Reverse:   A021010 [1, 1, 1, 1, 4, 2, 1, 9, 18, 6]
Inverse:   A021009 [1, -1, 1, 2, -4, 1, -6, 18, -9, 1]
RevInv:    A021010 [1, 1, -1, 1, -4, 2, 1, -9, 18, -6]
Diagonal:  A084950 [1, 1, 2, 1, 6, 4, 24, 18, 1, 120]
Sum:       A002720 [1, 2, 7, 34, 209, 1546, 13327, 130922, 1441729, 17572114]
EvenSum:   A331325 [1, 1, 3, 15, 97, 745, 6571, 65359, 723969, 8842257]
OddSum:    A331326 [0, 1, 4, 19, 112, 801, 6756, 65563, 717760, 8729857]
AltSum:    A009940 [1, 0, -1, -4, -15, -56, -185, -204, 6209, 112400]
DiagSum:   C001040 [1, 1, 3, 10, 43, 225, 1393, 9976, 81201, 740785]
Central:   A295383 [1, 4, 72, 2400, 117600, 7620480, 614718720, 59364264960]
LeftSide:  A000142 [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
RightSide: A000012 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
PosHalf:   A025167 [1, 3, 17, 139, 1473, 19091, 291793, 5129307, 101817089]
NegHalf:   A025166 [1, -1, 1, 7, -127, 1711, -23231, 334391, -5144063, 84149983]
TransUnos: A002720 [1, 2, 7, 34, 209, 1546, 13327, 130922, 1441729, 17572114]
TransAlts: A009940 [1, 0, -1, -4, -15, -56, -185, -204, 6209, 112400]
TransSqrs: A105219 [0, 1, 8, 63, 544, 5225, 55656, 653023, 8379008, 116780049]
TransNat0: A103194 [0, 1, 6, 39, 292, 2505, 24306, 263431, 3154824, 41368977]
TransNat1: C000262 [1, 3, 13, 73, 501, 4051, 37633, 394353, 4596553, 58941091]
PolyVal2:  A087912 [1, 3, 14, 86, 648, 5752, 58576, 671568, 8546432, 119401856]
PolyVal3:  A277382 [1, 4, 23, 168, 1473, 14988, 173007, 2228544, 31636449]
```
"""
function xTraitCard(triangle::Function)
dim = 32
T = triangle(dim)
TraitCard(T, "$triangle ", dim, true)
end
# *** TrianglesUtils.jl ****************
const srcdir = realpath(joinpath(dirname(@__FILE__)))
const ROOTDIR = dirname(srcdir)
const datadir = joinpath(ROOTDIR, "data")
oeis_file() = joinpath(datadir, "stripped")
is_oeis_installed() = isfile(oeis_file())
function profilepath(name)
srcdir = realpath(joinpath(dirname(@__FILE__)))
ROOTDIR = dirname(srcdir)
datadir = joinpath(ROOTDIR, "profiles")
profilepath = joinpath(datadir, name * ".md")
end
function oeis_notinstalled()
if !is_oeis_installed()
@warn("OEIS data not installed! Download stripped.gz from oeis.org,")
@warn("expand it and put it in the directory ../data.")
return true
end
return false
end
function search_failed(name)
for ln ∈ eachline(name)
occursin("greeting", ln) && continue
occursin("{", ln) && continue
occursin("start", ln) && continue
if occursin("\"results\": null", ln)
return true
end 
end 
false
end            
"""
Search the OEIS for a sequence. The file is saved in the 'data' directory in json format.
"""
function oeis_search(seq)
seqstr = SeqToString(seq[1:min(end,12)])
filename = joinpath(datadir, seqstr[1:min(end,12)] * ".json")
uristr = "https://oeis.org/search?q=" * seqstr * "&go=Search&fmt=json"
url = HTTP.URI(uristr)
tries = 3
r = nothing
for i = 1:tries
try
r = HTTP.get(url; readtimeout = 2)
getfield(r, :status) == 200 && break
getfield(r, :status) == 302 && break
catch e
@warn(e)
end
sleep(2)
end
if !(r === nothing) && getfield(r, :status) == 200
open(filename, "w") do f
write(f, getfield(r, :body))
end
@info("Dowloaded " * basename(filename) * " to " * datadir)
else
if r === nothing
@warn("Search did not succeed, connection timed out.\n")
else
@warn("Search did not succeed, $url\nStatus: $(getfield(r, :status))")
end
end
filename
end
function SeqToString(seq::ℤSeq)
separator = ","
str = ""
for term in seq
str *= string(abs(term)) * separator
end
str
end
const minlen = 30  # fragil! do not reduce!
function GetSeqnum(seq::ℤSeq)
str = SeqToString(seq)
soff = 1; loff = 10 
for ln ∈ eachline(oeis_file())
ln[1] == '#' && continue
l = replace(ln, "-" => "")
m = min(length(str), length(l)) 
len = min(length(str), length(l)-loff) - 1
len < minlen && continue
cmp(str[soff:soff+len], l[loff:loff+len]) == 0 && return ln[1:7]
end
toff = findfirst(",", str)[1] + 1
for ln ∈ eachline(oeis_file())
ln[1] == '#' && continue
l = replace(ln, "-" => "")
len = min(length(str)-toff, length(l)-loff) - 1
len < minlen && continue
cmp(str[toff:toff+len], l[loff:loff+len]) == 0 && return "B" * ln[2:7]
end
for ln ∈ eachline(oeis_file())
ln[1] == '#' && continue
l = replace(ln, "-" => "")
ff = findnext(",", l, 10)
ff === nothing && continue
loff = ff[1] + 1; soff = 1
len = min(length(str)-soff, length(l)-loff) - 1
len < minlen && continue
cmp(str[soff:soff+len], l[loff:loff+len]) == 0 && return "C" * ln[2:7]
len = min(length(str)-toff, length(l)-loff) - 1
len < minlen && continue
cmp(str[toff:toff+len], l[loff:loff+len]) == 0 && return "D" * ln[2:7]
end
nothing
end
GetSeqnum(seq::ℤTri) = GetSeqnum(Flat(seq))
function GetSeqnum(seq, search=false)
if seq === nothing || seq == []
return nothing
end
anum = GetSeqnum(seq)
if search
if anum === nothing
filename = oeis_search(seq)
if ! search_failed(filename)
println()
Println(seq[1:min(18, end)])
@warn "Not found in the local base but possibly in the OEIS!"
println()
end
end
end
anum 
end
function print_without_type(io, v::AbstractVector)
print(io, "[")
for (i, el) ∈ enumerate(v)
i > 1 && print(io, ", ")
print(io, el)
end
println(io, "]")
end
"""

Print the array ``A`` in the format ``n ↦ A[n]`` for n in the given range.
"""
function MappedShow(A::Array, R::AbstractRange, offset=0)
for k ∈ R
if isassigned(A, k)
println(k + offset, " ↦ ", A[k])
else
println(k + offset, " ↦ ", "undef")
end
end
end
"""

Print an integer triangle without typeinfo.
"""
function Show(T::ℤTri, format="std")
if format == "std"  # default
for t in T[1:min(10, end)]
print_without_type(IOContext(stdout), t)
end
elseif format == "nest"
T |> println
elseif format == "flat"
for n in Flat(T)
print(n, ", ")
end
elseif format == "map"
offset = -1 # Julia is unfortunately 1-based.
for n in T
MappedShow(n, 1:length(n), offset)
offset += length(n)
end
elseif format == "info"
S = Flat(T)
print("[", GetSeqnum(S), "] ")
for t in T[1:min(5, end)], k in t
print(k, ", ")
end
println("... ")
end
end
end
